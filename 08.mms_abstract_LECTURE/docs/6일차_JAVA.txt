## ----------------------------------
##	JAVA 6일차 수업
## ----------------------------------

-- 객체지향 특징(OOP:Object Oriented Programming)
-- Encapsulation (은닉성)
-- Inheritance (상속)
-- Polymorphism (다형성)
	>> overloading(중복정의)
	>> 큰타입의 기억공간 (자동 형변환 : 작은타입의 데이터는 큰타입의기억공간 자동할당)
	>. overriding(재정의)
	
-- super
-- instanceof
	
-- Access Modifier **
-- this	**
-- type casting
	>> 자동 형변환 : 작은타입의 데이터는 큰타입의기억공간 자동할당
	>> 명시적 형변환 : 타입 변수명 = (타입)값;
-- overloading(중복정의)


## ----------------------------------
## Modifier (제한자, 제어자)
## ----------------------------------
1. Access Modifier (접근 제한자)
		1) + public : universe (누구나 접근가능)
		2) # protected : sub class(상속 받으면 접근 가능)
		3)   생략 : same package (다른 패키지 접근불가)
		4) - private : same class (다른 클래스 접근불가)
		
		-- 클래스 : public, 생략(default)
		-- 멤버변수, 메서드, 생성자 : public, protected, 생략, private
		-- 지역변수 : 생략
		
2. Usage Modifier (사용 제한자)
		1) static
		2) final
		3) abstract
		4) transient
		5) synchronized
		6) ...
		
		
## ----------------------------------
## Encapsulation (은닉성)
## ----------------------------------

1. 목적 : 정보 및 알고리즘 보호 (Information hiding)

2. 장점 : 안정성, 편리성, 유지보수성

3. 형식 :
	(1) private 멤버변수 선언  : private xxx;
	(2) public setter() / getter() 메서드 선언
	
		 -- setter() 메서드 형식 :
				public void setXxx(xxx타입 xxx) {
					// xxx 검증규칙에 올바른지 비교
					// 올바르면 값을 변경
					// 올바르지않으면 오류처리
				}
				
		 -- getter() 메서드 형식 :
				public xxx타입 getXxx() { 
					return xxx;
				}
		 
	(3) private 데이터변경전에 올바른 데이터인지 검증 메서드 선언
		-- setter() 메서드 내부에서 호출사용
		-- 검증규칙 메서드 형식 :
				private boolean isXxx(xxx타입 xxx) {
					if(검증조건) {
						return true;
					} else {
						return false;
					}
			}
			
			
			
## ----------------------------------
## Inheritance (상속):
## ----------------------------------

1. 목적: 
- 재사용성, 확장성, 유지보수성 향상
- 같은 종류의 객체들의 속성, 기능을 일반화 시켜 설계 (가전제품 <- 테레비, 라디오, 선풍기 등)
- 단일상속만 지원 (다중상속 개념으로 다중 인터페이스 구현 제공)	
- 계층적 상속 구조 : Object <- Super <- Sub

2. 방법: 

- 일반화시켜 모델링 되어 있는 부모클래스를 서브클래스에서 상속 정의
- 자식클래스(sub) 선언 방법 :
	public 서브클래스명 extends 부모클래스명 { }

- 부모클래스의 모든 멤버 상속
- 부모의 private 멤버도 상속은 되나 접근권한 제한으로 자식이 사용못함
- 부모의 생성자는 부모 객체를 생성시에 사용하는것이므로
- 서브클래스의 생성자에서 부모클래스의 생성자를 명시적으로 지정은 가능함
- 서브클래스에서 부모의 생성자 미지정시에는 자동으로 부모의 기본생성자로 생성됨 
- sub " is a " super 관계가 성립되어야만 올바른 부모클래스를 상속한것임
- 잘못하면 "Dog is a Person" 도 될수 있음


## ----------------------------------
## Polymorphism (다형성):
## ----------------------------------

1. 목적 : 
	- 메서드 및 변수에 다형성을 적용하여 유지보수성, 확장성, 재사용성의 효율을 높임
	- 적용 : 멤버변수타입, 매개변수타입, 반환타입, 배열타입, 메서드 
	- 즉, 부모타입의 변수로 선언하면 모든 자식객체를 담을수 있는 저장공간
	
2. 다형성 종류
	2.1 	Overloading (중복정의)
	- 같은 클래스, 또는 상속받은 메서드를 아규먼트 인자를 다르게 받도록 여러개 중복 정의
	- 메서드 이름은 동일하고,
	- 메서드의 아규먼트의 갯수, 순서, 타입은 반드시 다르게 지정해야함
	- 메서드의 반환타입, 접근제어자는 상관없음 (즉, 같아도 되고, 달라도 됨)
	
	2.2	Overriding (재정의)
	- 상속받은 메서드를 서브클래스에 맞도록 코드구현로직을 변경하여 사용함
	- 반환타입, 메서드이름, 메서드 아규먼트 갯수, 순서, 타입은 동일해야함
	- 접근권한은 부모클래스의 권한보다 축소될 수 없음(즉, 같거나 확장은 가능함)
	- 예외는 부모클래스의 예외보다 확장될 수 없음(즉, 없거나, 작거나, 같은 예외를 던져야함)

	2.3	부모타입으로 변수 선언 
	- 배열타입, 메서드의 매개변수 타입, 메서드의 반환타입, 단일변수타입
	- 부모타입의 참조변수로 서브객체를 reference 할 수 있음
	- 부모타입의 참조변수로는 서브객체의 멤버는 접근할 수 없음
	- 서브객체의 멤버를 접근하기 위해서는 서브객체타입으로 캐스팅하여 사용가능함
	- 예:	
		Person p = new Employee("홍길동", "인사팀", "서울시");
		p.name = "정유진"; 	// 부모의 멤버이므로 접근 가능
		p.dept = "감사팀";	// 자식멤버는 부모의 타입으로 접근 불가능하므로 컴파일오류
		Employee e = (Employee)p;
		e.dept = "감사팀"; 	// 자식타입으로 캐스팅후 자식객체의 멤버 접근 가능

	2.4	instanceof 키워드
	- 자식타입으로 캐스팅하는경우에 캐스팅하기전에 해당 객체의 인스턴스인지 검사
	- 예:  
		if (p instanceof Employee) { 
			Employee e = (Employee)p;
		} else {
			// 다른객체의 인스턴스이므로 캐스팅 오류 발생처리
		}
		
## ----------------------------------
## this 키워드	
## ----------------------------------
-- 객체생성시에 자동으로 제공하는 참조변수
-- 사용방법 :
	1. 현재 객체를 지칭 : this
	2. 멤버변수 지칭 : this.멤버변수명
		>> 멤버변수명과 지역변수명을 동일하게 사용가능
		>> 멤버변수를 this 식별가능하기때문에(편리)
	
	3. 현재 객체의 다른생성자를 호출시에 사용	
		>> 첫번째 수행문 위치
		>> this(params)
		>> 생성자 중복정의시에 효율적 : 중복 코드 제거, 로직의 일관성 유지, 유지보수 편리
		>> 객체생성시에 공통 로직 : 생성자 위임설계해서 this() 호출 사용

		
## ----------------------------------
## super 키워드
## ----------------------------------
- 부모 객체를 가르키는 참조변수

- 방법:
1) 부모의 멤버변수 및 멤버메서드를 가르킬때 사용
	super.부모멤버변수명;
	super.부모멤버메서드명();

2) 자식객체의 생성자에서 부모객체의 생성자 지정시 사용
	super(param데이터1, param데이터n);
	
	부모생성자를 지정하지 않으면 자동으로 super() 부여됨
	즉, 부모의 아규먼트를 받지 않는 생성자에 의해서 부모객체 생성함
	
	주의사항: 
	자식객체의 생성자의 첫번째 수행문으로 선언
	this() 와 super() 함께 사용 못함

## ----------------------------------
## instanceof 키워드
## ----------------------------------
1. 해당객체가 클래스의 인스턴스인지 확인해서 
   인스턴스이면 true 반환 그렇지 않으면 false를 반환
   객체타입으로 형변환 하기전에 확인한후 형변환 권장

2. 사용법:
	if (부모참조변수명 instancof 서브클래스이름) {
		서브클래스이름 자식참조변수명 = (서브클래스이름)부모참조변수명;
		
		// 캐스팅을 수행한 후에는 자식의 모든 멤버를 접근 가능함
		자식참조변수명.자식멤버변수명;
		자식참조변수명.자식멤버메서드명();
	} 

3. 주의
-- 다중 if ~ eles if ~ 로 instanceof 확인시에는 
   sub-class가 앞에 나오고 뒤에 super-class가 위치되어야함

-- 	if(참조변수명 instanceof Customer) {  // 맨앞에서 다 처리하므로 뒤에 서브로 내려가지않음
		
	} else if (참조변수명 instanceof GeneralCustomer) {
	
	} else if (참조변수명 instanceof SpecialCustomer) {
	
	}

