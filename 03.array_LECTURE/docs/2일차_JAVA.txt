## ----------------------------------
##	JAVA 2일차 수업
## ----------------------------------
-- Java 개발환경 구축
	>> jdk, eclipse, notepad++
	
-- Java 환경설정	
1. JAVA_HOME=C:\Program Files\Java\jdk1.8.0_202
2. PATH=%JAVA_HOME%\BIN;기존패스

-- ECLIPSE
	>> ide(통합개발환경), 오픈소스
	>> 프로젝트관리, 디버깅, 기타 기능
	>> 환경설정 : 한글인코딩(utf-8), java 8.0_202
	
-- 수업진행 폴더 
	>> C:\00.practice
	>> C:\00.practice\workspace_java
	

## TODO
1. 자바 프로그래밍 기본 
2. 식별자 
3. 데이터타입
4. 변수	
5. 연산자
6. 제어문 : 조건문, 반복문, 분기문
	
	
## 자바 파일 구조
1. package 선언문
-- 폴더같은 개념, 계층 구조
-- 같은 종류의 클래스를 같은 폴더에 관리
-- 관리 효율성, 이름 충돌 방지, 접근 권한 제어
-- 형식 : package 패키지명.패키지명;
-- 선언횟수 : 0, 1
-- package 선언하지 않으면 default package

2. import 선언문

3. class 선언문
-- 형식 :
	[modifiers] class 클래스이름 {
		// class 구성요소
	}
	
## class 구성요소
1. 멤버변수
2. 생성자
3. 메서드(매개변수) : 반환타입
	
[
	4. inner class
	5. static 블럭 초기화
	6. instance 블럭 초기화
}
	
	
## 자바 프로그래밍 기본 규칙
-- 자바 프로그래밍 시작 메서드 형식 : 규칙
	public static void main(String[] args) {
		// 수행문
	}
-- 대소문자 구분
-- {} 반드시 짝을 이루어서 열고 닫아야함
-- 이름규칙(자바 명명규칙) 준수 권장	

## 이름규칙(자바 명명규칙)
-- 클래스이름 : 
	>> 대문자시작 + 대문자시작
	>> System, String, HelloWorld, Member

-- 변수이름
	>> 첫단어는 모두 소문자 + 대문자시작
	>> companyName, minLength, age
	
-- 메서드이름
	>> 첫단어는 모두 소문자 + 대문자시작([매개변수타입 매개변수명, 매개변수타입 매개변수명])
	
-- 상수이름
	>> 모두대문자_모두대문자
	>> 구분자 _(밑줄)
	>> MAX_COUNT, MAX_VALUE, PI, E
	
-- 패키지이름
	>> 모두소문자.모두소문자
	>> 구분자 .(DOT)
	>> java.lang, java.util, com.work.view, com.work.model.dto
	
## 식별자 : identifier
-- 이름
-- 대소문자 구분
-- 길이 제한 없음
-- 시작 : 영문자, _, $
-- 조합 : 숫자 (숫자로 시작은 불가 => you4(ok), 4you(error))
-- keyword(예약어: 자바에서 이미 정의되어 있는 키워드) 사용 불가
-- 약어같은 경우에는 사용하지말것
	>> MH, DR, D, GJ, G
	>> ID, DAO, DTO : 누구나 알수 있는 약어는 사용하기도 함

## keyword(예약어)
-- 미리 사용이 정해져 있는 식별자
-- 모두 소문자 
-- public, static, void, class, package, for, if, switch 등
-- const : 키워드이지만 지원하지는 않음 (C언어 상수 표현 예약어)
-- sizeof : 키워드는 아니지만 식별자 지정 사용하지 말것 (C언어에서 데이터 타입의 크기를 체킹 예약어)

-- null : 어떠한 객체도 참조하지 않음, 객체 타입의 기본값
-- true / false : 참 / 거짓 

## 자바 데이터 타입
1. 기본형 
-- primitive type
-- 정수형 : byte(8bit), short(16bit), int(32bit, default), long(64bit)
	>> 5 (int)
	>> 5L (long, 대문자 L, 소문자 l)
	
-- 실수형 : float(32bit), double(64bit, default)
	>> 5.2 (double, D 생략가능), 5.2D, 5.2d
	>> 5.2F, 5.2f (float)

-- 논리형 : boolean
	>> true / false : 참 / 거짓
	
-- 단일문자형 : char(16bit, 2byte, unicode, 모든 언어 지원)
	>> 'A', '가'
	>> '\uXXXX', 공백문자 유니코드 : '\u0000'
	>> 특수문자 : '\n' 새로운 라인, '\t' tab key(일정간격띄우기), \', \", \\


2. 참조형(객체형)
-- reference type
-- 모든 클래스(인터페이스포함), 배열(array)

-- 문자열 클래스 : String
	>> 객체인데 기본형처럼 사용가능한 유일한 클래스
	>> "문자열"
	>> '가' : char 타입
	>> "가" : String 타입


## 변수(variable)
1. 멤버변수
-- 선언위치 : 클래스 구성요소
-- (1) 인스턴스 멤버변수 : static 붙지않은 멤버변수
-- (2) 클래스 멤버변수(static 변수) : static 붙은 멤버변수
-- 선언방법 :
	(1) [modifiers] 타입 멤버변수명;
	(2) [modifiers] 타입 멤버변수명 = 명시적초기값;
-- 멤버변수는 선언만 하면 기본값으로 객체 생성시 자동 초기화 수행

2. 지역변수
-- 선언위치 :
	>> 메서드 내부, 생성자 내부, 제어문 내부
	>> 메서드, 생성자 아규먼트 : 매개변수
	
-- 선언방법 :
	(1) 타입 변수명;
	(2) 타입 변수명 = 초기값;
	
-- 지역변수는 선언만 하면 자동 초기화가 수행되지 않음, 반드시 사용하기 전에 명시적으로 값을 초기화 수행해줘야함
	
## 형변환	
1. 자동형변환
-- 작은타입은 큰타입으로 자동형변환
-- 기본형에서 형변환 불가 타입 : boolean
-- 기본형 : byte => short, char => int => long => float => double
-- 참조형 : 자식클래스(sub class) => 부모클래스(super class)

2. 명시적(묵시적) 형변환
-- 큰타입을 작은타입으로 강제(명시적) 변환
-- 형식 : 타입 변수명 = (타입)값;
 
 
## modifiers(제어자, 제한자, 지정자)
1. Access Modifiers
-- 접근 권한 제어자
-- public : universe (누구나 필요시에 접근 허용)
-- protected : sub-class (다른 패키지에 있지만 상속을 받았다면 접근 허용)
-- 생략(package, default, friendly) : same package (같은 패키지에 있는 클래스들에게만 접근 허용)
-- private : same class (클래스 내부에서만 접근 허용)

-- class : public, 생략(package)
-- 멤버변수, 메서드, 생성자 : public, 생략(package), protected, private
-- 지역변수, 매개변수 : 생략(package)

2. Usage Modifiers(Non-Access Modifiers) 
-- 사용/활용 제어자
-- static
-- final
-- abstract

## 연산자
-- 할당연산자
	>> [타입] 변수명 = 값;
	>> 값, 변수명, 수식, 값을 반환하는 메서드호출문(), new 클래스이름() 객체생성
	
	>> = (할당) 연산자 수행 
	1. 왼쪽 기억공간타입과 저장하는 값의 타입이 같으면 자동 할당
	2. 왼쪽 기억공간타입이 저장하는 값의 타입보다 큰타입이면 자동 할당
	
	3. 왼쪽 기억공간의 타입이 큰타입도 아니고, 다른타입이면 오류 발생
	
	4. 욎쪽 기억공간의 타입이 다른 경우에 명시적으로 형변환을 하면 할당 가능
		>> 값의 유실이 발생할 수 있음
	
-- 산술연산자
	>> +, -, *, /(몫), %(나머지)
	>> + 중복연산자 
	>> 숫자 + 숫자 = 덧셈연산
	>> "문자열" + 숫자, 숫자 + "문자열", "문자열" + "문자열" : 연결연산자(concat)

-- 비교연산자 : 
	>> 값의 크기를 비교한 결과를 boolean 타입 반환, 제어문 조건식
	>> 왼쪽을 기준으로 결과 반환
	<, >, <=, >=, ==, !=
	
-- 논리연산자
	>> 조건식1 논리연산자 조건식2
	>> & (and) : 
		=> 조건식결과 모두 true => true, 조건식결과가 하나라도 false => false
		=> 조건식1수행결과 & 조건식2수행결과 => 결과에대해서 논리연산 수행결과 반환
		
	>> | (or) : 
		=> 조건식결과 모두 false => false, 조건식결과가 하나라도 true => true
	>> ! (not) : true이면 false, false 이면 true
	
	>> 단축 논리연산자
	>> && (and) : 
		=> 조건식1수행결과에 따라서 조건식2수행여부를 결정
		=> 조건식1수행결과가 false => 조건식2를 수행하지않고 결과를 false
		
	>> || (or) : 
		=> 조건식1수행결과가 true => 조건식2를 수행하지않고 결과를 true

-- 증감연산자
	>> 1을 더하거나, 1을 빼기 연산자, 제어문(반복문)
	>> ++, --
	>> 전치증감연산 : ++변수명, --변수명, 먼저1을 더하거나, 빼고나서 해당수행문 수행
	>> 후지증감연산 : 변수명++, 변수명--, 먼저 수행하고나서 1을 더하거나, 빼기

	int no = 5;
	System.out.println(++no); // 6
	System.out.println(no--); // 6 => 6-1=5
	System.out.println(no); // 5

-- 단축대입연산자
	>> +=, -=, *=, /=, %=, 제어문(반복문)
	>> int no = 5;
	>> no = no + 10
	>> no += 10;
	
-- 삼항연산자
	[타입] 변수명 = (조건식) ? 참인경우할당값 : 거짓인경우할당값;

## 제어문
-- 조건문, 반복문, 분기문

## 조건문
-- 조건식의 결과타입 : boolean

-- if (조건식) {
		// true 이면 수행문
   }

-- if (조건식) {
		// true 수행문
   } else {
		// false 수행문
   }

-- 다중조건문 
	if (조건식1) {
		// 조건식1 true 수행문
	} else if (조건식2) {
		// 조건식2 true 수행문
	}

-- 다중조건문 
	if (조건식1) {
		// 조건식1 true 수행문
	} else if (조건식2) {
		// 조건식2 true 수행문
	} else {
		// 해당 조건식에 부합되지 않는 경우 : 기본 수행 
	}

## 다중 조건문
-- expression 결과값에 수행 : 값, 변수명, 수식
-- type : int(byte, short, char), jdk7.x: String
-- 해당 case 부터 break; 구문을 만날때가지 순차적으로 수행
-- break; 구문을 or(또는 논리연산자처럼 사용가능)

switch(expression) {
	case 값1:
		값1인경우에 수행문
		[break;]
		
	case 값x:
		값x인경우에 수행문
		[break;]
	[
	default:
		기본수행
	]
}

## 반복문
-- 조건식이 true인 동안 반복 수행
-- for(), while(), do~while()
-- break; : 반복문을 빠져나감
-- continue; : 반복문의 조건식으로 분기해서 반복여부를 결정

-- for : jdk1.4
	>> 	for (초기값; 조건식; 증감값) {
			// 반복 수행문
		}
	>> 초기값 : 
		=> 0 ~ N, 다중 선언시에는 같은타입 가능, 타입 변수명 = 초기값
		=> int i = 1, j = x
		
	>> 조건식 : 0 or 1
	>> 증감값 : 0 ~ N
	
	>> 예시 : 1 ~ 10까지 반복 수행
		for (int i = 1; i <= 10; i++) {
			
		}

-- for : jdk1.5
	>> array, collection 


-- 	while(조건식) {}

	// 초기값 수행문 직접 표기
	while(조건식) {
		// 반복 수행문
		// 증감값 수행문 직접 표기
	};
	
	>> 반복수행전에 조건식을 비교해서 조건식이 거짓이면 한번도 수행하지 않음

-- do~while();
	// 초기값 수행문 직접 표기
	do {
		// 반복 수행문
		// 증감값 수행문 직접 표기
	} while(조건식);
	
	>> 최소 1번은 수행











	

	
	
	
	
	
	
	
	
	